[
    {
        "id": "flow_aspirador",
        "type": "tab",
        "label": "Rob√¥ Aspirador Inteligente",
        "disabled": false,
        "info": "Dashboard do Rob√¥ Aspirador com Sujeira Din√¢mica e Obst√°culos Aleat√≥rios"
    },
    {
        "id": "http_in",
        "type": "http in",
        "z": "flow_aspirador",
        "name": "Receber Dados",
        "url": "/aspirador",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 140,
        "wires": [["parse_json"]]
    },
    {
        "id": "parse_json",
        "type": "json",
        "z": "flow_aspirador",
        "name": "",
        "property": "payload",
        "action": "obj",
        "pretty": false,
        "x": 290,
        "y": 140,
        "wires": [["http_resp", "router"]]
    },
    {
        "id": "http_resp",
        "type": "http response",
        "z": "flow_aspirador",
        "name": "OK",
        "statusCode": "200",
        "x": 430,
        "y": 200,
        "wires": []
    },
    {
        "id": "router",
        "type": "switch",
        "z": "flow_aspirador",
        "name": "Tipo de Mensagem",
        "property": "payload.type",
        "propertyType": "msg",
        "rules": [
            {"t": "eq", "v": "simulation_start", "vt": "str"},
            {"t": "eq", "v": "periodic_update", "vt": "str"},
            {"t": "eq", "v": "simulation_end", "vt": "str"},
            {"t": "eq", "v": "comparison", "vt": "str"}
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 470,
        "y": 140,
        "wires": [
            ["fn_start"],
            ["fn_update", "fn_gauge_coverage", "fn_gauge_dirt", "fn_chart_trajectory", "fn_chart_energy", "fn_realtime_metrics"],
            ["fn_end", "fn_histogram_times", "fn_final_metrics"],
            ["fn_comparison"]
        ]
    },
    {
        "id": "fn_start",
        "type": "function",
        "z": "flow_aspirador",
        "name": "In√≠cio Simula√ß√£o",
        "func": "const d = msg.payload;\nconst config = d.config || {};\n\n// Limpar dados anteriores\nflow.set('trajectory', []);\nflow.set('history', flow.get('history') || []);\nflow.set('start_time', Date.now());\n\nmsg.payload = `üöÄ EXECU√á√ÉO ${d.execution} INICIADA\\n` +\n    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n` +\n    `üìê Arena: ${config.width || 6}m √ó ${config.height || 6}m\\n` +\n    `üß± Obst√°culos: ${config.num_obstacles || 0}\\n` +\n    `‚è±Ô∏è Tempo m√°ximo: 180s\\n` +\n    `üßπ Sujeira: 1 ponto/2s por 120s`;\n\nnode.status({fill:'blue', shape:'dot', text:'Exec ' + d.execution + ' iniciada'});\nreturn msg;",
        "outputs": 1,
        "x": 700,
        "y": 60,
        "wires": [["debug_main"]]
    },
    {
        "id": "fn_update",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Atualiza√ß√£o Peri√≥dica",
        "func": "const m = msg.payload.metrics || {};\nconst exec = msg.payload.execution || 1;\n\n// Salvar trajet√≥ria para mapa\nlet traj = flow.get('trajectory') || [];\nif (m.x !== undefined && m.y !== undefined) {\n    traj.push({\n        x: m.x,\n        y: m.y,\n        heading: m.heading || 0,\n        time: m.time_elapsed_s || 0\n    });\n    flow.set('trajectory', traj);\n}\n\n// Formatar sa√≠da com todas m√©tricas\nconst collected = m.dirt_collected || 0;\nconst spawned = m.dirt_spawned || 0;\nconst rate = spawned > 0 ? (collected / spawned * 100).toFixed(1) : 0;\n\nmsg.payload = `üìä Exec ${exec} | t=${(m.time_elapsed_s||0).toFixed(0)}s\\n` +\n    `Pos: (${(m.x||0).toFixed(2)}, ${(m.y||0).toFixed(2)}) Œ∏=${((m.heading||0)*180/Math.PI).toFixed(0)}¬∞\\n` +\n    `Vel: ${(m.linear_velocity||0).toFixed(2)}m/s | œâ=${(m.angular_velocity||0).toFixed(2)}rad/s\\n` +\n    `Sujeira: ${collected}/${spawned} (${rate}%)\\n` +\n    `Colis√µes: ${m.collisions||0} | Energia: ${(m.energy_consumed||0).toFixed(1)}J`;\n\nnode.status({fill:'green', shape:'dot', text:`${rate}% limpo | ${(m.time_elapsed_s||0).toFixed(0)}s`});\nreturn msg;",
        "outputs": 1,
        "x": 720,
        "y": 100,
        "wires": [["debug_main"]]
    },
    {
        "id": "fn_end",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Fim - M√©tricas Consolidadas",
        "func": "const s = msg.payload.summary || {};\nconst exec = msg.payload.execution;\n\n// Salvar no hist√≥rico\nlet history = flow.get('history') || [];\nhistory.push({\n    execution: exec,\n    coverage: s.coverage_percent,\n    time: s.total_time_s,\n    energy: s.energy_consumed,\n    distance: s.distance_traveled,\n    dirt_collected: s.dirt_collected,\n    dirt_spawned: s.dirt_spawned,\n    collisions: s.collisions,\n    temporal_efficiency: s.temporal_efficiency,\n    displacement_efficiency: s.displacement_efficiency\n});\nflow.set('history', history);\n\n// Calcular taxa de limpeza\nconst rate = s.dirt_spawned > 0 ? (s.dirt_collected / s.dirt_spawned * 100).toFixed(1) : 0;\n\nmsg.payload = `üèÅ EXECU√á√ÉO ${exec} FINALIZADA (t=180s)\\n` +\n    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n` +\n    `üìä M√âTRICAS CONSOLIDADAS:\\n` +\n    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n` +\n    `1. Total de pontos gerados:     ${s.dirt_spawned || 0}\\n` +\n    `2. Total de pontos limpos:      ${s.dirt_collected || 0}\\n` +\n    `3. Percentual de limpeza:       ${rate}%\\n` +\n    `4. Efici√™ncia temporal:         ${(s.temporal_efficiency||0).toFixed(2)}s\\n` +\n    `5. Efici√™ncia deslocamento:     ${(s.displacement_efficiency||0).toFixed(2)}m/ponto\\n` +\n    `6. N√∫mero de colis√µes:          ${s.collisions || 0}\\n` +\n    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n` +\n    `üìà OUTRAS M√âTRICAS:\\n` +\n    `Cobertura do mapa:    ${(s.coverage_percent||0).toFixed(1)}%\\n` +\n    `Energia consumida:    ${(s.energy_consumed||0).toFixed(1)}J\\n` +\n    `Dist√¢ncia percorrida: ${(s.distance_traveled||0).toFixed(2)}m`;\n\nnode.status({fill:'blue', shape:'ring', text:'Exec ' + exec + ' conclu√≠da'});\nreturn msg;",
        "outputs": 1,
        "x": 740,
        "y": 140,
        "wires": [["debug_main"]]
    },
    {
        "id": "fn_comparison",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Comparativo Final",
        "func": "const execs = msg.payload.executions || [];\nif (execs.length === 0) return null;\n\nlet txt = 'üìà COMPARATIVO DE EXECU√á√ïES\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n';\ntxt += 'Exec | Cobert% | Sujeira | Colis√µes | Efic.Desl\\n';\ntxt += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n';\n\nexecs.forEach(e => {\n    const sujeira = `${e.dirt_collected||0}/${e.dirt_spawned||0}`;\n    txt += `  ${e.execution}  |  ${(e.coverage_percent||0).toFixed(1)}%  |  ${sujeira}  |    ${e.collisions||0}     |  ${(e.displacement_efficiency||0).toFixed(2)}m/pt\\n`;\n});\n\n// Calcular melhoria\nif (execs.length >= 2) {\n    const first = execs[0];\n    const last = execs[execs.length-1];\n    const rateFirst = first.dirt_spawned > 0 ? first.dirt_collected / first.dirt_spawned : 0;\n    const rateLast = last.dirt_spawned > 0 ? last.dirt_collected / last.dirt_spawned : 0;\n    const improvement = ((rateLast - rateFirst) / (rateFirst || 1) * 100).toFixed(1);\n    txt += `\\nüìä Melhoria na taxa de limpeza: ${improvement}%`;\n}\n\nmsg.payload = txt;\nnode.status({fill:'yellow', shape:'dot', text:execs.length + ' execu√ß√µes comparadas'});\nreturn msg;",
        "outputs": 1,
        "x": 720,
        "y": 180,
        "wires": [["debug_main"]]
    },
    {
        "id": "fn_gauge_coverage",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Gauge Cobertura",
        "func": "const m = msg.payload.metrics || {};\nmsg.payload = m.coverage_percent || 0;\nmsg.topic = 'Cobertura (%)';\nreturn msg;",
        "outputs": 1,
        "x": 710,
        "y": 240,
        "wires": [["gauge_coverage"]]
    },
    {
        "id": "fn_gauge_dirt",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Gauge Taxa Limpeza",
        "func": "const m = msg.payload.metrics || {};\nconst collected = m.dirt_collected || 0;\nconst spawned = m.dirt_spawned || 0;\nconst rate = spawned > 0 ? (collected / spawned * 100) : 0;\n\nmsg.payload = rate;\nmsg.topic = 'Taxa de Limpeza (%)';\nreturn msg;",
        "outputs": 1,
        "x": 720,
        "y": 280,
        "wires": [["gauge_dirt"]]
    },
    {
        "id": "fn_chart_trajectory",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Mapa Trajet√≥ria",
        "func": "const m = msg.payload.metrics || {};\nif (m.x === undefined || m.y === undefined) return null;\n\n// Posi√ß√£o do rob√¥\nmsg.payload = {\n    x: m.x,\n    y: m.y,\n    heading: m.heading || 0\n};\n\n// Adicionar posi√ß√µes de sujeira se dispon√≠veis\nmsg.dirt_positions = m.dirt_positions || [];\nmsg.cleaned_positions = m.cleaned_positions || [];\n\nreturn msg;",
        "outputs": 1,
        "x": 720,
        "y": 400,
        "wires": [["chart_trajectory"]]
    },
    {
        "id": "fn_chart_energy",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Gr√°fico Energia/Pot√™ncia",
        "func": "const m = msg.payload.metrics || {};\nif (m.energy_consumed === undefined) return null;\n\nmsg.payload = m.energy_consumed || 0;\nmsg.topic = 'Energia (J)';\nreturn msg;",
        "outputs": 1,
        "x": 730,
        "y": 440,
        "wires": [["chart_energy"]]
    },
    {
        "id": "fn_histogram_times",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Histograma Tempos",
        "func": "const s = msg.payload.summary || {};\nconst travelTimes = s.travel_times || [];\n\nif (travelTimes.length === 0) return null;\n\n// Criar bins para histograma\nconst bins = [0, 2, 4, 6, 8, 10, 15, 20, 30, 60];\nconst counts = new Array(bins.length).fill(0);\n\ntravelTimes.forEach(t => {\n    for (let i = 0; i < bins.length - 1; i++) {\n        if (t >= bins[i] && t < bins[i + 1]) {\n            counts[i]++;\n            break;\n        }\n    }\n    if (t >= bins[bins.length - 1]) {\n        counts[bins.length - 1]++;\n    }\n});\n\n// Formatar para gr√°fico de barras\nconst labels = bins.map((b, i) => {\n    if (i === bins.length - 1) return `>${b}s`;\n    return `${b}-${bins[i+1]}s`;\n});\n\nmsg.payload = [{\n    series: ['Tempo para limpar'],\n    data: [counts],\n    labels: labels\n}];\n\nreturn msg;",
        "outputs": 1,
        "x": 720,
        "y": 520,
        "wires": [["chart_histogram"]]
    },
    {
        "id": "fn_final_metrics",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Indicadores Finais",
        "func": "const s = msg.payload.summary || {};\n\n// Enviar m√©tricas finais para gauges\nconst rate = s.dirt_spawned > 0 ? (s.dirt_collected / s.dirt_spawned * 100) : 0;\n\nmsg.payload = {\n    coverage: s.coverage_percent || 0,\n    dirt_rate: rate,\n    collisions: s.collisions || 0,\n    temporal_eff: s.temporal_efficiency || 0,\n    displacement_eff: s.displacement_efficiency || 0,\n    total_spawned: s.dirt_spawned || 0,\n    total_collected: s.dirt_collected || 0\n};\n\nreturn msg;",
        "outputs": 1,
        "x": 720,
        "y": 560,
        "wires": [["text_final_metrics"]]
    },
    {
        "id": "fn_realtime_metrics",
        "type": "function",
        "z": "flow_aspirador",
        "name": "M√©tricas Tempo Real",
        "func": "const m = msg.payload.metrics || {};\n\n// Calcular taxa de limpeza\nconst collected = m.dirt_collected || 0;\nconst spawned = m.dirt_spawned || 0;\nconst rate = spawned > 0 ? (collected / spawned * 100) : 0;\n\nmsg.payload = {\n    coverage: m.coverage_percent || 0,\n    dirt_rate: rate,\n    collisions: m.collisions || 0,\n    temporal_eff: m.avg_collection_time || 0,\n    displacement_eff: m.displacement_efficiency || 0,\n    total_spawned: spawned,\n    total_collected: collected\n};\n\nreturn msg;",
        "outputs": 1,
        "x": 730,
        "y": 600,
        "wires": [["text_final_metrics"]]
    },
    {
        "id": "gauge_coverage",
        "type": "ui_gauge",
        "z": "flow_aspirador",
        "name": "Cobertura",
        "group": "group_metrics",
        "order": 1,
        "width": "4",
        "height": "3",
        "gtype": "gage",
        "title": "Cobertura do Mapa",
        "label": "%",
        "format": "{{value | number:1}}",
        "min": 0,
        "max": 100,
        "colors": ["#CA3838", "#E6E600", "#00B500"],
        "seg1": "40",
        "seg2": "70",
        "diff": false,
        "className": "",
        "x": 920,
        "y": 240,
        "wires": []
    },
    {
        "id": "gauge_dirt",
        "type": "ui_gauge",
        "z": "flow_aspirador",
        "name": "Taxa de Limpeza",
        "group": "group_metrics",
        "order": 2,
        "width": "4",
        "height": "3",
        "gtype": "donut",
        "title": "Taxa de Limpeza",
        "label": "%",
        "format": "{{value | number:1}}",
        "min": 0,
        "max": 100,
        "colors": ["#CA3838", "#E6E600", "#00B500"],
        "seg1": "40",
        "seg2": "70",
        "diff": false,
        "className": "",
        "x": 930,
        "y": 280,
        "wires": []
    },
    {
        "id": "chart_trajectory",
        "type": "ui_template",
        "z": "flow_aspirador",
        "group": "group_map",
        "name": "Mapa da Arena",
        "order": 1,
        "width": "12",
        "height": "8",
        "format": "<style>\n    #arena-canvas { border: 2px solid #333; background: #f5f5f0; border-radius: 50%; }\n</style>\n<canvas id=\"arena-canvas\" width=\"400\" height=\"400\"></canvas>\n<script>\n(function(scope) {\n    const canvas = document.getElementById('arena-canvas');\n    const ctx = canvas.getContext('2d');\n    const scale = 60;\n    const centerX = 200;\n    const centerY = 200;\n    const radius = 3 * scale;\n    \n    let trajectory = [];\n    let dirtPositions = [];\n    let cleanedPositions = [];\n    let robotPos = {x: 3, y: 0.9, heading: 0};\n    \n    function draw() {\n        ctx.clearRect(0, 0, 400, 400);\n        \n        // Fundo circular\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);\n        ctx.fillStyle = '#f5f5f0';\n        ctx.fill();\n        ctx.strokeStyle = '#666';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n        \n        // Grid circular\n        ctx.strokeStyle = '#ddd';\n        ctx.lineWidth = 0.5;\n        for (let r = 0.5; r < 3; r += 0.5) {\n            ctx.beginPath();\n            ctx.arc(centerX, centerY, r * scale, 0, 2 * Math.PI);\n            ctx.stroke();\n        }\n        \n        // Trajet√≥ria\n        if (trajectory.length > 1) {\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgba(33, 150, 243, 0.6)';\n            ctx.lineWidth = 2;\n            trajectory.forEach((p, i) => {\n                const px = centerX + (p.x - 3) * scale;\n                const py = centerY - (p.y - 3) * scale;\n                if (i === 0) ctx.moveTo(px, py);\n                else ctx.lineTo(px, py);\n            });\n            ctx.stroke();\n        }\n        \n        // Sujeira n√£o coletada (marrom)\n        dirtPositions.forEach(d => {\n            const px = centerX + (d[0] - 3) * scale;\n            const py = centerY - (d[1] - 3) * scale;\n            ctx.beginPath();\n            ctx.arc(px, py, 5, 0, 2 * Math.PI);\n            ctx.fillStyle = '#8B4513';\n            ctx.fill();\n            ctx.strokeStyle = '#5D2E0C';\n            ctx.lineWidth = 1;\n            ctx.stroke();\n        });\n        \n        // Sujeira coletada (verde)\n        cleanedPositions.forEach(d => {\n            const px = centerX + (d[0] - 3) * scale;\n            const py = centerY - (d[1] - 3) * scale;\n            ctx.beginPath();\n            ctx.arc(px, py, 5, 0, 2 * Math.PI);\n            ctx.fillStyle = 'rgba(76, 175, 80, 0.5)';\n            ctx.fill();\n        });\n        \n        // Rob√¥\n        const rx = centerX + (robotPos.x - 3) * scale;\n        const ry = centerY - (robotPos.y - 3) * scale;\n        \n        ctx.beginPath();\n        ctx.arc(rx, ry, 10, 0, 2 * Math.PI);\n        ctx.fillStyle = '#1565C0';\n        ctx.fill();\n        ctx.strokeStyle = '#0D47A1';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        \n        // Dire√ß√£o\n        const dirX = rx + 15 * Math.cos(-robotPos.heading);\n        const dirY = ry + 15 * Math.sin(-robotPos.heading);\n        ctx.beginPath();\n        ctx.moveTo(rx, ry);\n        ctx.lineTo(dirX, dirY);\n        ctx.strokeStyle = '#FF5722';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n    }\n    \n    scope.$watch('msg', function(msg) {\n        if (msg && msg.payload) {\n            robotPos = {\n                x: msg.payload.x || robotPos.x,\n                y: msg.payload.y || robotPos.y,\n                heading: msg.payload.heading || 0\n            };\n            trajectory.push({x: robotPos.x, y: robotPos.y});\n            if (trajectory.length > 1000) trajectory.shift();\n            \n            if (msg.dirt_positions) dirtPositions = msg.dirt_positions;\n            if (msg.cleaned_positions) cleanedPositions = msg.cleaned_positions;\n            \n            draw();\n        }\n    });\n    \n    draw();\n})(scope);\n</script>",
        "storeOutMessages": false,
        "fwdInMessages": false,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 930,
        "y": 400,
        "wires": [[]]
    },
    {
        "id": "chart_energy",
        "type": "ui_chart",
        "z": "flow_aspirador",
        "name": "Energia Consumida",
        "group": "group_energy",
        "order": 1,
        "width": "12",
        "height": "4",
        "label": "Consumo de Energia (Proxy: Torque √ó Velocidade)",
        "chartType": "line",
        "legend": "true",
        "xformat": "HH:mm:ss",
        "interpolate": "linear",
        "nodata": "Aguardando dados...",
        "dot": false,
        "ymin": "0",
        "ymax": "",
        "removeOlder": "5",
        "removeOlderPoints": "200",
        "removeOlderUnit": "60",
        "cutout": 0,
        "useOneColor": false,
        "useUTC": false,
        "colors": ["#FF7F0E", "#1F77B4"],
        "outputs": 1,
        "useDifferentColor": false,
        "className": "",
        "x": 940,
        "y": 440,
        "wires": [[]]
    },
    {
        "id": "chart_histogram",
        "type": "ui_chart",
        "z": "flow_aspirador",
        "name": "Histograma de Tempos",
        "group": "group_performance",
        "order": 1,
        "width": "12",
        "height": "4",
        "label": "Histograma: Tempo para Limpar Cada Ponto",
        "chartType": "bar",
        "legend": "false",
        "xformat": "auto",
        "interpolate": "linear",
        "nodata": "Aguardando fim da execu√ß√£o...",
        "dot": false,
        "ymin": "0",
        "ymax": "",
        "removeOlder": 1,
        "removeOlderPoints": "",
        "removeOlderUnit": "3600",
        "cutout": 0,
        "useOneColor": false,
        "useUTC": false,
        "colors": ["#4CAF50"],
        "outputs": 1,
        "useDifferentColor": false,
        "className": "",
        "x": 940,
        "y": 520,
        "wires": [[]]
    },
    {
        "id": "text_final_metrics",
        "type": "ui_template",
        "z": "flow_aspirador",
        "group": "group_performance",
        "name": "Indicadores Finais",
        "order": 2,
        "width": "12",
        "height": "4",
        "format": "<style>\n    .metrics-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; padding: 10px; }\n    .metric-card { background: #f5f5f5; border-radius: 8px; padding: 15px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n    .metric-value { font-size: 28px; font-weight: bold; color: #1565C0; }\n    .metric-label { font-size: 11px; color: #666; margin-top: 5px; text-transform: uppercase; }\n    .good { color: #4CAF50 !important; }\n    .warning { color: #FF9800 !important; }\n    .bad { color: #F44336 !important; }\n</style>\n<div class=\"metrics-grid\">\n    <div class=\"metric-card\">\n        <div class=\"metric-value\">{{msg.payload.total_collected || 0}}/{{msg.payload.total_spawned || 0}}</div>\n        <div class=\"metric-label\">Pontos Limpos / Gerados</div>\n    </div>\n    <div class=\"metric-card\">\n        <div class=\"metric-value\" ng-class=\"{'good': msg.payload.dirt_rate > 70, 'warning': msg.payload.dirt_rate > 40, 'bad': msg.payload.dirt_rate <= 40}\">{{(msg.payload.dirt_rate || 0).toFixed(1)}}%</div>\n        <div class=\"metric-label\">Percentual de Limpeza</div>\n    </div>\n    <div class=\"metric-card\">\n        <div class=\"metric-value\" ng-class=\"{'good': msg.payload.collisions < 10, 'warning': msg.payload.collisions < 25, 'bad': msg.payload.collisions >= 25}\">{{msg.payload.collisions || 0}}</div>\n        <div class=\"metric-label\">N√∫mero de Colis√µes</div>\n    </div>\n    <div class=\"metric-card\">\n        <div class=\"metric-value\">{{(msg.payload.temporal_eff || 0).toFixed(2)}}s</div>\n        <div class=\"metric-label\">Efici√™ncia Temporal</div>\n    </div>\n    <div class=\"metric-card\">\n        <div class=\"metric-value\">{{(msg.payload.displacement_eff || 0).toFixed(2)}}m</div>\n        <div class=\"metric-label\">Efici√™ncia Deslocamento</div>\n    </div>\n    <div class=\"metric-card\">\n        <div class=\"metric-value\">{{(msg.payload.coverage || 0).toFixed(1)}}%</div>\n        <div class=\"metric-label\">Cobertura do Mapa</div>\n    </div>\n</div>",
        "storeOutMessages": false,
        "fwdInMessages": false,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 940,
        "y": 560,
        "wires": [[]]
    },
    {
        "id": "debug_main",
        "type": "debug",
        "z": "flow_aspirador",
        "name": "ü§ñ Aspirador Log",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 930,
        "y": 120,
        "wires": []
    },
    {
        "id": "group_metrics",
        "type": "ui_group",
        "name": "üìä M√©tricas em Tempo Real",
        "tab": "tab_main",
        "order": 1,
        "disp": true,
        "width": "12",
        "collapse": false,
        "className": ""
    },
    {
        "id": "group_map",
        "type": "ui_group",
        "name": "üó∫Ô∏è Mapa da Arena com Trajet√≥ria",
        "tab": "tab_main",
        "order": 2,
        "disp": true,
        "width": "12",
        "collapse": false,
        "className": ""
    },
    {
        "id": "group_robot",
        "type": "ui_group",
        "name": "ü§ñ Estado do Rob√¥",
        "tab": "tab_main",
        "order": 3,
        "disp": true,
        "width": "12",
        "collapse": false,
        "className": ""
    },
    {
        "id": "group_energy",
        "type": "ui_group",
        "name": "‚ö° Consumo de Energia (Proxy: Torque √ó Velocidade)",
        "tab": "tab_energy",
        "order": 1,
        "disp": true,
        "width": "12",
        "collapse": false,
        "className": ""
    },
    {
        "id": "group_performance",
        "type": "ui_group",
        "name": "üìà Indicadores de Desempenho Final (t=180s)",
        "tab": "tab_performance",
        "order": 1,
        "disp": true,
        "width": "12",
        "collapse": false,
        "className": ""
    },
    {
        "id": "tab_main",
        "type": "ui_tab",
        "name": "ü§ñ Monitoramento",
        "icon": "dashboard",
        "order": 1,
        "disabled": false,
        "hidden": false
    },
    {
        "id": "tab_energy",
        "type": "ui_tab",
        "name": "‚ö° Energia",
        "icon": "fa-bolt",
        "order": 2,
        "disabled": false,
        "hidden": false
    },
    {
        "id": "tab_performance",
        "type": "ui_tab",
        "name": "üìà Desempenho",
        "icon": "fa-chart-bar",
        "order": 3,
        "disabled": false,
        "hidden": false
    }
]
